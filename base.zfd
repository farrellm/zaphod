(def car
     (forall a (-> (cons a ()) Top))
     (unsafe-coerce fst))

(def cdr
     (forall a (-> (cons a ()) Top))
     (unsafe-coerce snd))

(def tuple'
     (-> (cons Top ()) Top)
     (lambda (t)
       (if (is-nil t) (: () Top)
           (cons 'cons
                 (cons (car t)
                       (cons (tuple' (cdr t))
                             ()))))))

(def tuple
     (-> Top Top)
     (macro t (tuple' t)))

(def defn
     (-> [(Symbol . Top) Type Top] Top)
     (macro (p t e)
       ['def (car p) t ['lambda (cdr p) e]]))

(def defmacro
     (-> [(Symbol . Top) Type Top] Top)
     (macro (p t e)
       ['def (car p) t ['macro (cdr p) e]]))

(defn (top-foldr f i l)
  (forall a (forall b (-> [(-> [b a] a) a Top] a)))
  (if (is-nil l) i
      (f (unsafe-coerce (car l))
         (top-foldr f i (cdr l)))))

(defn (mk-forall u e)
  (-> [Symbol Top] Top)
  ['forall u e])

(defmacro (forall us e)
  (-> [Top Top] Top)
  (if (is-symbol us)
      (mk-forall (unsafe-coerce us) e)
      (top-foldr mk-forall e us)))

(defn (top-foldl f i l)
  (forall (a b) (-> [(-> [a b] a) a Top] a))
  (if (is-nil l) i
      (top-foldl f (f i (unsafe-coerce (car l))) (cdr l))))

(defn (top-map f l)
  (forall (a b) (-> [(-> [a] b) Top] Top))
  (top-foldr (lambda (x ys)
               (: (cons (f x) ys) Top))
             ()
             l))

(defn (compose f g)
  (forall (a b c)
          (-> [(-> [b] c) (-> [a] b)]
              (-> [a] c)))
  (lambda (x) (f (g x))))

(def caar (compose car car))
(def cadr (compose car cdr))
(def cdar (compose cdr car))
(def cddr (compose cdr cdr))
(def caddr (compose car cddr))

(defn (mk-let b e)
  (forall a (-> [[Symbol Top] a] Top))
  [['lambda [(fst b)] e] (fst (snd b))])

(defmacro (let ps e)
  (-> [Top Top] Top)
  (top-foldr mk-let e ps))

(defn (foralls xs e)
  (-> [Top Top] Top)
  (top-foldr
   (lambda (x e) (: ['forall x e] Top))
   e
   xs))

(defn (gen-syms xs)
  (-> [Top] Top)
  (top-map (lambda (_) (unsafe-gensym)) xs))

(defn (constructor n xs c)
  (-> [Symbol Top Top] Top)
  (if (is-symbol c)
      (: ['def c
               (foralls xs (cons n xs))
               ['unsafe-coerce ['quote c]]]
         Top)
      (let ((c' (cons (car c) (gen-syms (cdr c)))))
        ['defn c'
          (foralls xs ['-> (cons 'tuple (cdr c)) (cons n xs)])
          ['unsafe-coerce (cons 'tuple (cons ['quote (car c')] (cdr c')))]])))

(defn (data' n xs cs)
  (-> [Symbol Top Top] Top)
  (cons
   'begin
   (cons
    ['def n ['lambda xs [': (cons 'tuple (cons ['quote n] xs)) 'Type]]]
    (top-map (lambda (c) (constructor n xs c))
             cs))))

(def data
     (-> ((Symbol . Top) . Top) Top)
     (macro d (data' (fst (fst d)) (cdar d) (cdr d))))

(defn (top-init xs)
  (forall (a) (-> [a] Top))
  (if (is-nil (cdr xs))
      (: () Top)
      (cons (car xs) (top-init (cdr xs)))))

(defn (top-last xs)
  (forall (a) (-> [a] Top))
  (if (is-nil (cdr xs))
      (car xs)
      (top-last (cdr xs))))

(def cond
     (-> Top Top)
     (macro cs
       (top-foldr (: (lambda (c e) ['if (car c) (cadr c) e])
                     (-> [[Top Top] Top] Top))
                  (top-last cs)
                  (top-init cs))))
