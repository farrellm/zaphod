(def car
     (-> (cons Any ()) Any)
     (unsafe-coerce fst))

(def cdr
     (-> (cons Any ()) Any)
     (unsafe-coerce snd))

(def tuple'
     (-> (cons Any ()) Any)
     (lambda (t)
       (if (is-nil t) (: () Any)
           (cons 'cons
                 (cons (car t)
                       (cons (tuple' (cdr t))
                             ()))))))

(def tuple
     (-> Any Any)
     (macro t (tuple' t)))

(def caar (-> [Any] Any) (lambda (x) (car (car x))))
(def cdar (-> [Any] Any) (lambda (x) (cdr (car x))))
(def cadr (-> [Any] Any) (lambda (x) (car (cdr x))))
(def cddr (-> [Any] Any) (lambda (x) (cdr (cdr x))))

(def caaar (-> [Any] Any) (lambda (x) (car (car (car x)))))
(def caadr (-> [Any] Any) (lambda (x) (car (car (cdr x)))))
(def cadar (-> [Any] Any) (lambda (x) (car (cdr (car x)))))
(def cdaar (-> [Any] Any) (lambda (x) (cdr (car (car x)))))
(def caddr (-> [Any] Any) (lambda (x) (car (cdr (cdr x)))))
(def cdadr (-> [Any] Any) (lambda (x) (cdr (car (cdr x)))))
(def cddar (-> [Any] Any) (lambda (x) (cdr (cdr (car x)))))
(def cdddr (-> [Any] Any) (lambda (x) (cdr (cdr (cdr x)))))

(def defn
     (-> [(cons Symbol Any) Type Any] Any)
     (macro (p t e)
       ['def (fst p) t ['lambda (snd p) e]]))

(def defmacro
     (-> [(cons Symbol Any) Type Any] Any)
     (macro (p t e)
       ['def (car p) t ['macro (cdr p) e]]))

(defn (top-foldr f i l)
  (_forall a (_forall b (-> [(-> [b a] a) a Any] a)))
  (if (is-nil l) i
      (f (unsafe-coerce (car l))
         (top-foldr f i (cdr l)))))

(defn (mk-forall u e)
  (-> [Symbol Any] Any)
  ['_forall u e])

(defmacro (forall us e)
  (-> [Any Any] Any)
  (top-foldr mk-forall e us))

(defn (top-foldl f i l)
  (forall (a b) (-> [(-> [a b] a) a Any] a))
  (if (is-nil l) i
      (top-foldl f (f i (unsafe-coerce (car l))) (cdr l))))

(defn (top-map f l)
  (forall (a b) (-> [(-> [a] b) Any] Any))
  (top-foldr (lambda (x ys)
               (: (cons (f x) ys) Any))
             ()
             l))

(defn (compose f g)
  (forall (a b c)
          (-> [(-> [b] c) (-> [a] b)]
              (-> [a] c)))
  (lambda (x) (f (g x))))

(defn (mk-let b e)
  (forall (a) (-> [[Symbol Any] a] Any))
  [['lambda [(fst b)] e] (fst (snd b))])

(defmacro (let ps e)
  (-> [Any Any] Any)
  (top-foldr mk-let e ps))

(defn (foralls xs e)
  (-> [Any Any] Any)
  (if (is-nil xs)
      (: e Any)
      ['forall xs e]))

(defn (unsafe-gensyms xs)
  (-> [Any] Any)
  (top-map (lambda (_) (unsafe-gensym)) xs))

(defn (const x)
  (forall (a b) (-> [a] (-> [b] a)))
  (lambda (_) x))

(defn (constructor1 n c)
  (-> [Any Any] Any)
  (if (is-symbol c)
      (: ['def c
               n
               ['unsafe-coerce ['quote c]]]
         Any)
      (let ((c' (cons (car c) (unsafe-gensyms (cdr c)))))
        ['defn c'
          ['-> (cons 'tuple (cdr c)) n]
          ['unsafe-coerce (cons 'tuple (cons ['quote (car c')] (cdr c')))]])))

(defn (constructor n xs c)
  (-> [Any Any Any] Any)
  (if (is-symbol c)
      (: ['def c
               (foralls xs (cons n xs))
               ['unsafe-coerce ['quote c]]]
         Any)
      (let ((c' (cons (car c) (unsafe-gensyms (cdr c)))))
        ['defn c'
          (foralls xs ['-> (cons 'tuple (cdr c)) (cons n xs)])
          ['unsafe-coerce (cons 'tuple (cons ['quote (car c')] (cdr c')))]])))

(defn (data1 n cs)
  (-> [Any Any] Any)
  (cons
   'begin
   (cons
    ['def n
          'Type
          ['quote n]]
    (top-map (lambda (c) (constructor1 n c))
             cs))))

(defn (data' n xs cs)
  (-> [Any Any Any] Any)
  (cons
   'begin
   (cons
    ['def n
          ['-> (cons 'tuple (top-map (const 'Type) xs)) 'Type]
          ['lambda xs [': (cons 'tuple (cons ['quote n] xs)) 'Type]]]
    (top-map (lambda (c) (constructor n xs c))
             cs))))

(def data
     (-> (cons Any Any) Any)
     (macro d
       (if (is-symbol (car d))
           (data1 (car d) (cdr d))
           (data' (caar d) (cdar d) (cdr d)))))

(defn (top-init xs)
  (forall (a) (-> [a] Any))
  (if (is-nil (cdr xs))
      (: () Any)
      (cons (car xs) (top-init (cdr xs)))))

(defn (top-last xs)
  (forall (a) (-> [a] Any))
  (if (is-nil (cdr xs))
      (car xs)
      (top-last (cdr xs))))

(def cond
     (-> Any Any)
     (macro cs
       (top-foldr (: (lambda (c e) ['if (car c) (cadr c) e])
                     (-> [[Any Any] Any] Any))
                  (top-last cs)
                  (top-init cs))))
