(data (Bool)
      (False)
      (True))

(data (Maybe a)
      (Nothing)
      (Just a))

(data (Either a b)
      (Left a)
      (Right b))

(data (List a)
      (Nil)
      (Cons a (List a)))

(data (Nat)
      (Z)
      (S (Nat)))

(defn (id x)
  (forall (a) (-> [a] a))
  x)

(defn (top-append xs ys)
  (forall (a b) (-> [a b] Any))
  (top-foldr (lambda (x a) (: (cons x a) Any))
             ys
             xs))

(defn (top-reverse' xs ys)
  (forall (a b) (-> [a b] Any))
  (if (is-nil xs)
      (: ys Any)
      (top-reverse' (cdr xs) (cons (car xs) ys))))

(defn (top-reverse xs)
  (forall (a) (-> [a] Any))
  (top-reverse' xs ()))

(defn (not p)
  (-> [(Bool)] (Bool))
  (if p (False) (True)))

(defn (unsafe-from-just m)
  (forall (a) (-> [(Maybe a)] a))
  (unsafe-coerce (cadr m)))

(defn (maybe d f m)
  (forall (a b) (-> [b (-> [a] b) (Maybe a)] b))
  (if (top-eq m (Nothing))
      d
      (f (unsafe-from-just m))))

(defn (curry f x)
  (forall (a b c) (-> [(-> (cons b a) c) b]
                      (-> a c)))
  (lambda y (apply f (cons x y))))
